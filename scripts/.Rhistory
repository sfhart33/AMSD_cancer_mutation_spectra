)
})
return(results)
}
sims= 10000
# Case 1: corrected, each type vs genome-wide mutations
results_uncorr_GW <- run_amsd_loop(partitioned_final, type, ref = "all", sims = sims)
partitioned_final
View(partitioned)
files <- list.files("colo_spectrum", full.names = TRUE)
# --- COLO tables ---
colo_files <- files[grepl("COLO829TB", files) & !grepl("DBS78", files)]
colo_tables <- colo_files %>%
set_names(basename(.)) %>%
map(~ read_tsv(.x, show_col_types = FALSE))
# Rename each value column to the filename
colo_tables <- imap(colo_tables, ~ rename(.x, !!.y := 2))
# Merge all by MutationType
COLO829TB_merged <- reduce(colo_tables, full_join, by = "MutationType")
# --- Kmer tables ---
kmer_files <- files[grepl("kmer", files)]
kmer_tables <- kmer_files %>%
set_names(basename(.)) %>%
map(~ read_tsv(.x, show_col_types = FALSE))
# Merge by "3mer"
kmer_merged <- reduce(kmer_tables, full_join, by = "3mer")
# Put them in order
COLO829TB_ordered <- COLO829TB_merged %>%
separate(MutationType, into = c("a","b"), sep = "\\[", remove = FALSE) %>%
separate(b, into = c("b","c"), sep = "\\]") %>%
arrange(b,a,c) %>%
select(-a,-b,-c) %>%
column_to_rownames(var = "MutationType") %>%
t() %>%
as.data.frame()
##########################
# Calculate kmer mutational opportunities and put samples in same order
sample_counts <- COLO829TB_ordered
kmer_C <- kmer_merged %>%
filter(str_sub(`3mer`, 2, 2) == "C")
kmer_T <- kmer_merged %>%
filter(str_sub(`3mer`, 2, 2) == "T")
oppertunities <- rbind(kmer_C,kmer_C,kmer_C,kmer_T,kmer_T,kmer_T) %>%
select(-`3mer`) %>%
t() %>%
as.data.frame()/3 # correction for tripling everything
colnames(oppertunities) <- colnames(sample_counts )
samples_ordered <- COLO829TB_ordered %>%
rownames_to_column(var = "name") %>%
separate(name, into = c("name", NA, NA), sep = "\\.") %>%
separate(name, into = c(NA,"type"), sep = "Filtered_") %>%
filter(!is.na(type)) %>%
column_to_rownames(var = "type")
oppertunities_ordered <- select(as.data.frame(t(oppertunities)), rownames(samples_ordered)) %>%
t() %>%
as.data.frame()
# one way to correct - unbiased spectra
# corrected <- samples_ordered/opportunities_ordered
# corrected_spectra <- corrected/rowSums(corrected)*rowSums(samples_ordered)
# other way to correct that I used - convert to full genome
full_genome_oppertunities <- oppertunities[rep("count", nrow(oppertunities_ordered)),] # full genome kmers
corrected <- samples_ordered*full_genome_oppertunities/oppertunities_ordered # correct each sample for full genome kmers
corrected_spectra <- corrected/rowSums(corrected)*rowSums(samples_ordered) # correct to make sure mutaion counts add up same
corrected_spectra_rounded <- round(corrected_spectra) # round to integer
plot_spectrum(oppertunities, pdf_path = "oppertunities.pdf")
plot_spectrum(corrected_spectra_rounded, pdf_path = "corrected_spectra_rounded.pdf")
plot_spectrum(samples_ordered, pdf_path = "spectra.pdf")
##########################
# Subset into individual mutations before and after correcting for mutational opportunities
# function to participation into multiple samples
partition_mutations_fast <- function(mat, group_size = 10, min_total = 100) {
# mat: data.frame or matrix with rows = samples, cols = mutation types (SBS96)
# group_size: number of mutations per partition
# min_total: only process rows with >= this many mutations
results <- vector("list", nrow(mat))
sample_names <- rownames(mat)
mut_types <- colnames(mat)
for (s in seq_len(nrow(mat))) {
row_counts <- mat[s, ]
total_mut <- sum(row_counts)
if (total_mut < min_total) {
next
}
# Number of groups
n_groups <- ceiling(total_mut / group_size)
# Instead of expanding, assign group IDs directly
group_ids <- sample(rep(seq_len(n_groups), each = group_size, length.out = total_mut))
# Create matrix to hold group counts
group_counts <- matrix(0, nrow = n_groups, ncol = length(mut_types),
dimnames = list(NULL, mut_types))
# Efficiently distribute counts to groups
mut_index <- rep(seq_along(mut_types), times = row_counts)
for (i in seq_along(mut_index)) {
group_counts[group_ids[i], mut_index[i]] <- group_counts[group_ids[i], mut_index[i]] + 1
}
# Convert to tibble
df <- as.data.frame(group_counts)
df$Sample <- sample_names[s]
df$Group <- seq_len(n_groups)
df$n_mutations <- rowSums(group_counts)
results[[s]] <- tibble::as_tibble(df)
}
dplyr::bind_rows(results)
}
# Run on uncorrected
partitioned <- partition_mutations_fast(COLO829TB_ordered, group_size = 1, min_total = 100)
partitioned_final <- partitioned %>%
separate(Sample, into = c("name", NA, NA), sep = "\\.") %>%
separate(name, into = c(NA,"type"), sep = "Filtered_") %>%
filter(!is.na(type))
# Run on ucorrected
partitioned_corrected <- partition_mutations_fast(corrected_spectra_rounded, group_size = 1, min_total = 100)
# Check results
partitioned_final
partitioned_corrected
##########################
# run AMSD
run_amsd_loop <- function(df, group_col, ref = "all", sims = 10000) {
# group_col is the column name you want to iterate over (unquoted, e.g. Sample or type)
group_col <- rlang::ensym(group_col)
pvalues <- c()
cosines <- c()
repeat1s <- c()
for (repeat1 in unique(dplyr::pull(df, !!group_col))) {
message("starting ", repeat1)
set1 <- df %>%
filter(!!group_col == repeat1, n_mutations > 1) %>%
select(-!!group_col, -Group, -n_mutations)
if (ref == "all") {
# compare against everything
set2 <- df %>%
filter(n_mutations > 1) %>%
select(-!!group_col, -Group, -n_mutations)
} else {
# compare against a specific reference group value
set2 <- df %>%
filter(!!group_col == ref, n_mutations > 1) %>%
select(-!!group_col, -Group, -n_mutations)
}
amsd_output <- amsd(set1, set2, mean_or_sum = "sum", seed = 1234, n_sim = sims)
pvalues <- c(pvalues, amsd_output$p)
cosines <- c(cosines, amsd_output$cosine)
repeat1s <- c(repeat1s, repeat1)
}
# return tidy data frame with appropriately named columns
results <- data.frame(
pvalue = pvalues,
cosine_dist = cosines,
group = repeat1s
)
return(results)
}
run_amsd_loop <- function(df, group_col, ref = "all", sims = 10000) {
group_col <- ensym(group_col)
# Pre-filter for mutation count, but KEEP grouping column
df_filtered <- df %>%
#filter(n_mutations > 1) %>%
select(-Group, -n_mutations)
# Build reference set ONCE
if (ref == "all") {
set2 <- df_filtered %>% select(-!!group_col)
} else {
set2 <- df_filtered %>%
filter(!!group_col == ref) %>%
select(-!!group_col)
}
# Iterate
results <- map_dfr(unique(dplyr::pull(df, !!group_col)), function(repeat1) {
message("starting ", repeat1)
set1 <- df_filtered %>%
filter(!!group_col == repeat1) %>%
select(-!!group_col)
# skip if no rows left
if (nrow(set1) == 0 || nrow(set2) == 0) {
return(NULL)
}
amsd_output <- amsd(set1, set2, mean_or_sum = "mean",
seed = 1234, n_sim = sims)
tibble(
pvalue = amsd_output$p,
cosine_dist = amsd_output$cosine,
group = repeat1
)
})
return(results)
}
sims= 10000
# Case 1: corrected, each type vs genome-wide mutations
results_uncorr_GW <- run_amsd_loop(partitioned_final, type, ref = "all", sims = sims)
# Case 2: corrected, each type vs genome-wide mutations
results_corr_GW <- run_amsd_loop(partitioned_corrected, Sample, ref = "all", sims = sims)
# Case 3: uncorrected, each type vs non-repeat
results_uncorr_NR <- run_amsd_loop(partitioned_final, type, ref = "None_RE", sims = sims)
# Case 4: corrected, each Sample vs non-repeat
results_corr_NR <- run_amsd_loop(partitioned_corrected, Sample, ref = "None_RE", sims = sims)
################################
# plot and output result
results_uncorr_GW
results_corr_GW
results_uncorr_NR
results_corr_NR
merged <- bind_rows(
results_uncorr_GW %>%
mutate(correction = "uncorrected", comparison = "vs genome-wide mutations"),
results_corr_GW %>%
mutate(correction = "corrected", comparison = "vs genome-wide mutations"),
results_uncorr_NR %>%
mutate(correction = "uncorrected", comparison = "vs non-repeat"),
results_corr_NR %>%
mutate(correction = "corrected", comparison = "vs non-repeat")
)
# Save as TSV
write_tsv(merged, "merged_amsd_results.tsv")
plot_amsd_results <- function(results, sims, title, exclude_group = NULL, ref_results = NULL) {
# Optionally filter out a group
if (!is.null(exclude_group)) {
results <- results %>% filter(group != exclude_group)
}
# number of tests (Bonferroni correction)
n_tests <- nrow(results)
if (!is.null(ref_results)) {
# allow using another results object to set n_tests if desired
n_tests <- nrow(ref_results)
}
# thresholds
sim_thresh   <- -log10(1 / sims)
bonf_thresh  <- -log10(0.05 / n_tests)
p05_thresh   <- -log10(0.05)
# make plot
ggplot(results, aes(cosine_dist, -log10(pvalue), label = group)) +
geom_point() +
geom_hline(yintercept = sim_thresh) +
geom_hline(yintercept = bonf_thresh, linetype = "dashed") +
geom_hline(yintercept = p05_thresh, linetype = "dotted") +
# labels
annotate("text", x = max(results$cosine_dist, na.rm=TRUE), y = sim_thresh,
label = "p = 1/permutaions", vjust = -0.5, hjust = 1, size = 3.5) +
annotate("text", x = max(results$cosine_dist, na.rm=TRUE), y = bonf_thresh,
label = "Bonf. 0.05/n", vjust = -0.5, hjust = 1, size = 3.5) +
annotate("text", x = max(results$cosine_dist, na.rm=TRUE), y = p05_thresh,
label = "p = 0.05", vjust = -0.5, hjust = 1, size = 3.5) +
ylim(0, max(4.5, sim_thresh, bonf_thresh, p05_thresh)) +
geom_label_repel() +
theme_classic() +
ggtitle(title)
}
plot_amsd_results(results_uncorr_GW, sims,
title = "Result from AMSD, NOT corrected for kmers\nvs genome-wide mutation spectra") %>%
ggsave("results_uncorr_GW.pdf", plot = ., width = 6, height = 4)
plot_amsd_results(results_corr_GW, sims,
title = "Result from AMSD, NOT corrected for kmers\nvs genome-wide mutation spectra") %>%
ggsave("results_corr_GW.pdf", plot = ., width = 6, height = 4)
plot_amsd_results(results_uncorr_NR, sims,
title = "Result from AMSD, corrected for kmer content\nvs non-repeat mutation spectra",
exclude_group = "None_RE") %>%
ggsave("results_uncorr_NR.pdf", plot = ., width = 6, height = 4)
plot_amsd_results(results_corr_NR, sims,
title = "Result from AMSD, corrected for kmer content\nvs non-repeat mutation spectra",
exclude_group = "None_RE") %>%
ggsave("results_corr_NR.pdf", plot = ., width = 6, height = 4)
###
# try fitting with sigfit?
corrected_spectra_rounded
data("cosmic_signatures_v3.2")
data("cosmic_signatures_v3.3")
cosmic_signatures_v3.2
tail(cosmic_signatures_v3.2)
comsmic_v3.4 <- read_delim("COSMIC_v3.4_SBS_GRCh38")
getwd()
comsmic_v3.4 <- read_delim("COSMIC_v3.4_SBS_GRCh38.txt")
comsmic_v3.4
comsmic_v3.4 %>%
column_to_rownames(var = "Type") %>%
t() %>%
as.data.frame()
comsmic_v3.4
comsmic_v3.4 %>%
separate(Type, into = c("a","bc"), sep = "[")
comsmic_v3.4 %>%
separate(Type, into = c("a","bc"), sep = "\\[")
comsmic_v3.4 %>%
separate(Type, into = c("a","bc"), sep = "\\[") %>%
separate(bc, into = c("b","c"), sep = "\\[") %>%
arrange(b,a,c)
comsmic_v3.4 %>%
separate(Type, into = c("a","bc"), sep = "\\[") %>%
separate(bc, into = c("b","c"), sep = "\\]") %>%
arrange(b,a,c)
comsmic_v3.4 %>%
separate(Type, into = c("a","bc"), sep = "\\[", remove = FALSE) %>%
separate(bc, into = c("b","c"), sep = "\\]") %>%
arrange(b,a,c) %>%
select(-a,-b,-c) %>%
column_to_rownames(var = "Type") %>%
t() %>%
as.data.frame()
comsmic_v3.4_ordered <- comsmic_v3.4 %>%
separate(Type, into = c("a","bc"), sep = "\\[", remove = FALSE) %>%
separate(bc, into = c("b","c"), sep = "\\]") %>%
arrange(b,a,c) %>%
select(-a,-b,-c) %>%
column_to_rownames(var = "Type") %>%
t() %>%
as.data.frame()
mcmc_samples_fit <- fit_signatures(counts = corrected_spectra_rounded,
signatures = comsmic_v3.4_ordered,
iter = 2000,
warmup = 1000,
chains = 1,
seed = 1756)
exposures <- retrieve_pars(mcmc_samples_fit,
par = "exposures",
hpd_prob = 0.90)
exposures$mean
exposures1 <- exposures$mean
exposures1
exposures1[exposures1 < 0.01] <- 0
exposures1 <- exposures$mean
exposures1[exposures1 < 0.01] <- 0
exposures1
cosmic_signatures_v3.3
cosmic_signatures_v3.2
cosmic_signatures_v3.2 %>% rownames()
library(tidyverse)
# source("amsd_functions.R")
library(mutspecdist)
library(SigProfilerAssignmentR)
library(sigfit)
data("cosmic_signatures_v3.2")
# Ancestry calls from: https://gdc.cancer.gov/about-data/publications/CCG-AIM-2020
#--- helper: convert sigfit-style spectra to SigProfiler SBS96 input
convert_sigfit_to_SigProfiler <- function(sigfit_matrix) {
mat_t <- t(sigfit_matrix)
convert_label <- function(x) {
ref   <- substr(x, 2, 2)
alt   <- substr(x, 6, 6)
left  <- substr(x, 1, 1)
right <- substr(x, 3, 3)
paste0(left, "[", ref, ">", alt, "]", right)
}
rownames(mat_t) <- sapply(rownames(mat_t), convert_label)
sbs96_channels <- c(
"A[C>A]A","A[C>A]C","A[C>A]G","A[C>A]T","A[C>G]A","A[C>G]C","A[C>G]G","A[C>G]T",
"A[C>T]A","A[C>T]C","A[C>T]G","A[C>T]T","A[T>A]A","A[T>A]C","A[T>A]G","A[T>A]T",
"A[T>C]A","A[T>C]C","A[T>C]G","A[T>C]T","A[T>G]A","A[T>G]C","A[T>G]G","A[T>G]T",
"C[C>A]A","C[C>A]C","C[C>A]G","C[C>A]T","C[C>G]A","C[C>G]C","C[C>G]G","C[C>G]T",
"C[C>T]A","C[C>T]C","C[C>T]G","C[C>T]T","C[T>A]A","C[T>A]C","C[T>A]G","C[T>A]T",
"C[T>C]A","C[T>C]C","C[T>C]G","C[T>C]T","C[T>G]A","C[T>G]C","C[T>G]G","C[T>G]T",
"G[C>A]A","G[C>A]C","G[C>A]G","G[C>A]T","G[C>G]A","G[C>G]C","G[C>G]G","G[C>G]T",
"G[C>T]A","G[C>T]C","G[C>T]G","G[C>T]T","G[T>A]A","G[T>A]C","G[T>A]G","G[T>A]T",
"G[T>C]A","G[T>C]C","G[T>C]G","G[T>C]T","G[T>G]A","G[T>G]C","G[T>G]G","G[T>G]T",
"T[C>A]A","T[C>A]C","T[C>A]G","T[C>A]T","T[C>G]A","T[C>G]C","T[C>G]G","T[C>G]T",
"T[C>T]A","T[C>T]C","T[C>T]G","T[C>T]T","T[T>A]A","T[T>A]C","T[T>A]G","T[T>A]T",
"T[T>C]A","T[T>C]C","T[T>C]G","T[T>C]T","T[T>G]A","T[T>G]C","T[T>G]G","T[T>G]T"
)
mat_ordered <- mat_t[sbs96_channels, , drop = FALSE]
df <- as.data.frame(mat_ordered)
df <- cbind(MutationType = rownames(df), df)
rownames(df) <- NULL
return(df)
}
# ANCESTRY (anc2 excludes admixed, anc3 includes with closest ancestry group)
anc_calls <- read.table("../inputs/tcga_ancestry_calls.txt",
header=TRUE,
comment.char="",
sep = "\t") %>%
select(IID = patient, tumor_type, consensus_ancestry) %>%
mutate(anc2 = consensus_ancestry, anc3 = consensus_ancestry,) %>%
mutate(across(anc2, str_replace, 'afr_admix', 'admix')) %>%
mutate(across(anc2, str_replace, 'eas_admix', 'admix')) %>%
mutate(across(anc2, str_replace, 'sas_admix', 'admix')) %>%
mutate(across(anc2, str_replace, 'eur_admix', 'admix')) %>%
mutate(across(anc3, str_replace, 'afr_admix', 'afr')) %>%
mutate(across(anc3, str_replace, 'eas_admix', 'eas')) %>%
mutate(across(anc3, str_replace, 'sas_admix', 'sas')) %>%
mutate(across(anc3, str_replace, 'eur_admix', 'eur'))
getwd()
setwd("C:/Users/sfhar/AMSD_cancer_mutation_spectra/scripts/Assignment_no_1/")
setwd("C:/Users/sfhar/AMSD_cancer_mutation_spectra/scripts")
# ANCESTRY (anc2 excludes admixed, anc3 includes with closest ancestry group)
anc_calls <- read.table("../inputs/tcga_ancestry_calls.txt",
header=TRUE,
comment.char="",
sep = "\t") %>%
select(IID = patient, tumor_type, consensus_ancestry) %>%
mutate(anc2 = consensus_ancestry, anc3 = consensus_ancestry,) %>%
mutate(across(anc2, str_replace, 'afr_admix', 'admix')) %>%
mutate(across(anc2, str_replace, 'eas_admix', 'admix')) %>%
mutate(across(anc2, str_replace, 'sas_admix', 'admix')) %>%
mutate(across(anc2, str_replace, 'eur_admix', 'admix')) %>%
mutate(across(anc3, str_replace, 'afr_admix', 'afr')) %>%
mutate(across(anc3, str_replace, 'eas_admix', 'eas')) %>%
mutate(across(anc3, str_replace, 'sas_admix', 'sas')) %>%
mutate(across(anc3, str_replace, 'eur_admix', 'eur'))
# SPECTRA
tcga_3mer <- read.table("../inputs/tcga_mutation_spectra.txt",
sep="\t",
header = TRUE) %>%
separate(ID, into = c("a","b","c",NA,NA,NA,NA), sep = "-") %>%
mutate(IID = paste(a,b,c,sep = "-")) %>%
select(-a,-b,-c) %>%
select(IID, everything())
tcga_3mer_spectra <- tcga_3mer
tcga_3mer_spectra[,2:97] <- tcga_3mer[,2:97]/rowSums(tcga_3mer[,2:97])
tcga_3mer_spectra$mut_counts <- rowSums(select(tcga_3mer, -IID))
tcga_3mer$mut_counts <- rowSums(select(tcga_3mer, -IID))
# merge
anc_spectra <- inner_join(anc_calls, tcga_3mer_spectra)
anc_counts <- inner_join(anc_calls, tcga_3mer)
saveRDS(anc_spectra, "../outputs/ancestry_spectra.rds")
# Run AMSD
min_mutations <- 10
min_sample <- 5
anc_tumor_counts <- anc_counts %>%
filter(mut_counts >= min_mutations) %>%
count(tumor_type, anc3) %>%
filter(anc3 %in% c("afr", "eas","eur")) %>%
filter(n >= min_sample) %>%
select(-n)
anc_tumor_comparisons <- select(anc_tumor_counts, tumor_type, ancestry1=anc3) %>%
full_join(select(anc_tumor_counts, tumor_type, ancestry2=anc3),
relationship = "many-to-many") %>%
mutate(comparison = paste0(ancestry1, "_", ancestry2)) %>%
filter(comparison %in% c("afr_eas","afr_eur","eas_eur"))
anc_counts
# Blank variables for outputs
pvalues <- c()
cosines <- c()
reps <- 100000
perms <- data.frame(rep = 1:reps)
count <- 1
# set variables
tissue_type <- anc_tumor_comparisons[count,"tumor_type"]
ancestry1 <- anc_tumor_comparisons[count,"ancestry1"]
ancestry2 <- anc_tumor_comparisons[count,"ancestry2"]
# Sample groupings
samples_anc1 <- anc_spectra %>%
filter(tumor_type == tissue_type,
anc3 == ancestry1,
mut_counts >= min_mutations) %>%
select(-IID, -tumor_type, -consensus_ancestry, -anc2, -anc3, -mut_counts)
samples_anc2 <- anc_spectra %>%
filter(tumor_type == tissue_type,
anc3 == ancestry2,
mut_counts >= min_mutations) %>%
select(-IID, -tumor_type, -consensus_ancestry, -anc2, -anc3, -mut_counts)
# Run AMSD
amsd_output <- amsd(samples_anc1,
samples_anc2,
mean_or_sum = "mean",
n_sim = reps,
seed = 123)
# Save output
pvalues <- c(pvalues, amsd_output$p)
cosines <- c(cosines, amsd_output$cosine)
perms1 <- data.frame(perms = amsd_output$sims)
colnames(perms1) <- paste0(tissue_type, ".", ancestry1,"_", ancestry2)
perms <- cbind(perms, perms1)
print(paste(count, "of", nrow(anc_tumor_comparisons)))
###################### NEW
# --- Run SigProfiler fitting for ancestry group 1 (sample-level) ---
sp_anc1 <- convert_sigfit_to_SigProfiler(samples_anc1)  # rows = samples, cols = SBS96
sp_anc1
samples_anc1
# function to convert your colnames into SigProfiler SBS96 format
convert_to_SBS96 <- function(df) {
mat <- as.matrix(df)
rownames(mat) <- NULL
# transpose so samples = columns
mat_t <- t(mat)
# Build fake SBS96 names (SigProfiler expects them in the COSMIC-defined order)
# Here we just number them SBS1 ... SBS96 unless you want exact context labels
colnames(mat_t) <- paste0("Sample", seq_len(ncol(mat_t)))
rownames(mat_t) <- paste0("Channel", seq_len(nrow(mat_t)))
return(mat_t)
}
sp_anc1 <- convert_to_SBS96(samples_anc1)
sp_anc1
anc_tumor_comparisons
?cosmic_fit
cosmic_fit()
cosmic_fit(
samples = sp_anc1,
output = outdir_anc1,
input_type = "matrix",
context_type = "96",
collapse_to_SBS96 = TRUE
)
library(SigProfilerAssignmentR)
SigProfilerAssignmentR::cosmic_fit(
samples = sp_anc1,
output = outdir_anc1,
input_type = "matrix",
context_type = "96",
collapse_to_SBS96 = TRUE
)
library(reticulate)
cosmic_fit(
samples = sp_anc1,
output = outdir_anc1,
input_type = "matrix",
context_type = "96",
collapse_to_SBS96 = TRUE
)
reticulate::py_config()
reticulate::py_module_available("SigProfilerAssignment")
# should return TRUE
library(tidyverse)
# source("amsd_functions.R")
library(mutspecdist)
library(reticulate)
use_python("C:/Users/sfhar/AppData/Local/Programs/Python/Python313/python.exe", required = TRUE)
